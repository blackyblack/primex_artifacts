/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import type { TypedEventFilter, TypedEvent, TypedListener } from "./common";

interface IDataStorageOperatorInterface extends ethers.utils.Interface {
  functions: {
    "calculateVolumePerLiquidity(uint128,int256,int256)": FunctionFragment;
    "changeFeeConfiguration((uint16,uint16,uint32,uint32,uint16,uint16,uint32,uint16,uint16))": FunctionFragment;
    "getAverages(uint32,int24,uint16,uint128)": FunctionFragment;
    "getFee(uint32,int24,uint16,uint128)": FunctionFragment;
    "getSingleTimepoint(uint32,uint32,int24,uint16,uint128)": FunctionFragment;
    "getTimepoints(uint32,uint32[],int24,uint16,uint128)": FunctionFragment;
    "initialize(uint32,int24)": FunctionFragment;
    "timepoints(uint256)": FunctionFragment;
    "window()": FunctionFragment;
    "write(uint16,uint32,int24,uint128,uint128)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "calculateVolumePerLiquidity",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "changeFeeConfiguration",
    values: [
      {
        alpha1: BigNumberish;
        alpha2: BigNumberish;
        beta1: BigNumberish;
        beta2: BigNumberish;
        gamma1: BigNumberish;
        gamma2: BigNumberish;
        volumeBeta: BigNumberish;
        volumeGamma: BigNumberish;
        baseFee: BigNumberish;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getAverages",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getFee",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getSingleTimepoint",
    values: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getTimepoints",
    values: [
      BigNumberish,
      BigNumberish[],
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "timepoints",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "window", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "write",
    values: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: "calculateVolumePerLiquidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeFeeConfiguration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAverages",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getFee", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getSingleTimepoint",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTimepoints",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "timepoints", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "window", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "write", data: BytesLike): Result;

  events: {
    "FeeConfiguration(tuple)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "FeeConfiguration"): EventFragment;
}

export type FeeConfigurationEvent = TypedEvent<
  [
    [number, number, number, number, number, number, number, number, number] & {
      alpha1: number;
      alpha2: number;
      beta1: number;
      beta2: number;
      gamma1: number;
      gamma2: number;
      volumeBeta: number;
      volumeGamma: number;
      baseFee: number;
    }
  ] & {
    feeConfig: [
      number,
      number,
      number,
      number,
      number,
      number,
      number,
      number,
      number
    ] & {
      alpha1: number;
      alpha2: number;
      beta1: number;
      beta2: number;
      gamma1: number;
      gamma2: number;
      volumeBeta: number;
      volumeGamma: number;
      baseFee: number;
    };
  }
>;

export class IDataStorageOperator extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: IDataStorageOperatorInterface;

  functions: {
    calculateVolumePerLiquidity(
      liquidity: BigNumberish,
      amount0: BigNumberish,
      amount1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { volumePerLiquidity: BigNumber }>;

    changeFeeConfiguration(
      feeConfig: {
        alpha1: BigNumberish;
        alpha2: BigNumberish;
        beta1: BigNumberish;
        beta2: BigNumberish;
        gamma1: BigNumberish;
        gamma2: BigNumberish;
        volumeBeta: BigNumberish;
        volumeGamma: BigNumberish;
        baseFee: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    getAverages(
      time: BigNumberish,
      tick: BigNumberish,
      index: BigNumberish,
      liquidity: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        TWVolatilityAverage: BigNumber;
        TWVolumePerLiqAverage: BigNumber;
      }
    >;

    getFee(
      time: BigNumberish,
      tick: BigNumberish,
      index: BigNumberish,
      liquidity: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[number] & { fee: number }>;

    getSingleTimepoint(
      time: BigNumberish,
      secondsAgo: BigNumberish,
      tick: BigNumberish,
      index: BigNumberish,
      liquidity: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        tickCumulative: BigNumber;
        secondsPerLiquidityCumulative: BigNumber;
        volatilityCumulative: BigNumber;
        volumePerAvgLiquidity: BigNumber;
      }
    >;

    getTimepoints(
      time: BigNumberish,
      secondsAgos: BigNumberish[],
      tick: BigNumberish,
      index: BigNumberish,
      liquidity: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber[], BigNumber[], BigNumber[]] & {
        tickCumulatives: BigNumber[];
        secondsPerLiquidityCumulatives: BigNumber[];
        volatilityCumulatives: BigNumber[];
        volumePerAvgLiquiditys: BigNumber[];
      }
    >;

    initialize(
      time: BigNumberish,
      tick: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    timepoints(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [boolean, number, BigNumber, BigNumber, BigNumber, number, BigNumber] & {
        initialized: boolean;
        blockTimestamp: number;
        tickCumulative: BigNumber;
        secondsPerLiquidityCumulative: BigNumber;
        volatilityCumulative: BigNumber;
        averageTick: number;
        volumePerLiquidityCumulative: BigNumber;
      }
    >;

    window(
      overrides?: CallOverrides
    ): Promise<[number] & { windowLength: number }>;

    write(
      index: BigNumberish,
      blockTimestamp: BigNumberish,
      tick: BigNumberish,
      liquidity: BigNumberish,
      volumePerLiquidity: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  calculateVolumePerLiquidity(
    liquidity: BigNumberish,
    amount0: BigNumberish,
    amount1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  changeFeeConfiguration(
    feeConfig: {
      alpha1: BigNumberish;
      alpha2: BigNumberish;
      beta1: BigNumberish;
      beta2: BigNumberish;
      gamma1: BigNumberish;
      gamma2: BigNumberish;
      volumeBeta: BigNumberish;
      volumeGamma: BigNumberish;
      baseFee: BigNumberish;
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  getAverages(
    time: BigNumberish,
    tick: BigNumberish,
    index: BigNumberish,
    liquidity: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber] & {
      TWVolatilityAverage: BigNumber;
      TWVolumePerLiqAverage: BigNumber;
    }
  >;

  getFee(
    time: BigNumberish,
    tick: BigNumberish,
    index: BigNumberish,
    liquidity: BigNumberish,
    overrides?: CallOverrides
  ): Promise<number>;

  getSingleTimepoint(
    time: BigNumberish,
    secondsAgo: BigNumberish,
    tick: BigNumberish,
    index: BigNumberish,
    liquidity: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber] & {
      tickCumulative: BigNumber;
      secondsPerLiquidityCumulative: BigNumber;
      volatilityCumulative: BigNumber;
      volumePerAvgLiquidity: BigNumber;
    }
  >;

  getTimepoints(
    time: BigNumberish,
    secondsAgos: BigNumberish[],
    tick: BigNumberish,
    index: BigNumberish,
    liquidity: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber[], BigNumber[], BigNumber[], BigNumber[]] & {
      tickCumulatives: BigNumber[];
      secondsPerLiquidityCumulatives: BigNumber[];
      volatilityCumulatives: BigNumber[];
      volumePerAvgLiquiditys: BigNumber[];
    }
  >;

  initialize(
    time: BigNumberish,
    tick: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  timepoints(
    index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [boolean, number, BigNumber, BigNumber, BigNumber, number, BigNumber] & {
      initialized: boolean;
      blockTimestamp: number;
      tickCumulative: BigNumber;
      secondsPerLiquidityCumulative: BigNumber;
      volatilityCumulative: BigNumber;
      averageTick: number;
      volumePerLiquidityCumulative: BigNumber;
    }
  >;

  window(overrides?: CallOverrides): Promise<number>;

  write(
    index: BigNumberish,
    blockTimestamp: BigNumberish,
    tick: BigNumberish,
    liquidity: BigNumberish,
    volumePerLiquidity: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    calculateVolumePerLiquidity(
      liquidity: BigNumberish,
      amount0: BigNumberish,
      amount1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    changeFeeConfiguration(
      feeConfig: {
        alpha1: BigNumberish;
        alpha2: BigNumberish;
        beta1: BigNumberish;
        beta2: BigNumberish;
        gamma1: BigNumberish;
        gamma2: BigNumberish;
        volumeBeta: BigNumberish;
        volumeGamma: BigNumberish;
        baseFee: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<void>;

    getAverages(
      time: BigNumberish,
      tick: BigNumberish,
      index: BigNumberish,
      liquidity: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        TWVolatilityAverage: BigNumber;
        TWVolumePerLiqAverage: BigNumber;
      }
    >;

    getFee(
      time: BigNumberish,
      tick: BigNumberish,
      index: BigNumberish,
      liquidity: BigNumberish,
      overrides?: CallOverrides
    ): Promise<number>;

    getSingleTimepoint(
      time: BigNumberish,
      secondsAgo: BigNumberish,
      tick: BigNumberish,
      index: BigNumberish,
      liquidity: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        tickCumulative: BigNumber;
        secondsPerLiquidityCumulative: BigNumber;
        volatilityCumulative: BigNumber;
        volumePerAvgLiquidity: BigNumber;
      }
    >;

    getTimepoints(
      time: BigNumberish,
      secondsAgos: BigNumberish[],
      tick: BigNumberish,
      index: BigNumberish,
      liquidity: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber[], BigNumber[], BigNumber[]] & {
        tickCumulatives: BigNumber[];
        secondsPerLiquidityCumulatives: BigNumber[];
        volatilityCumulatives: BigNumber[];
        volumePerAvgLiquiditys: BigNumber[];
      }
    >;

    initialize(
      time: BigNumberish,
      tick: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    timepoints(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [boolean, number, BigNumber, BigNumber, BigNumber, number, BigNumber] & {
        initialized: boolean;
        blockTimestamp: number;
        tickCumulative: BigNumber;
        secondsPerLiquidityCumulative: BigNumber;
        volatilityCumulative: BigNumber;
        averageTick: number;
        volumePerLiquidityCumulative: BigNumber;
      }
    >;

    window(overrides?: CallOverrides): Promise<number>;

    write(
      index: BigNumberish,
      blockTimestamp: BigNumberish,
      tick: BigNumberish,
      liquidity: BigNumberish,
      volumePerLiquidity: BigNumberish,
      overrides?: CallOverrides
    ): Promise<number>;
  };

  filters: {
    "FeeConfiguration(tuple)"(
      feeConfig?: null
    ): TypedEventFilter<
      [
        [
          number,
          number,
          number,
          number,
          number,
          number,
          number,
          number,
          number
        ] & {
          alpha1: number;
          alpha2: number;
          beta1: number;
          beta2: number;
          gamma1: number;
          gamma2: number;
          volumeBeta: number;
          volumeGamma: number;
          baseFee: number;
        }
      ],
      {
        feeConfig: [
          number,
          number,
          number,
          number,
          number,
          number,
          number,
          number,
          number
        ] & {
          alpha1: number;
          alpha2: number;
          beta1: number;
          beta2: number;
          gamma1: number;
          gamma2: number;
          volumeBeta: number;
          volumeGamma: number;
          baseFee: number;
        };
      }
    >;

    FeeConfiguration(
      feeConfig?: null
    ): TypedEventFilter<
      [
        [
          number,
          number,
          number,
          number,
          number,
          number,
          number,
          number,
          number
        ] & {
          alpha1: number;
          alpha2: number;
          beta1: number;
          beta2: number;
          gamma1: number;
          gamma2: number;
          volumeBeta: number;
          volumeGamma: number;
          baseFee: number;
        }
      ],
      {
        feeConfig: [
          number,
          number,
          number,
          number,
          number,
          number,
          number,
          number,
          number
        ] & {
          alpha1: number;
          alpha2: number;
          beta1: number;
          beta2: number;
          gamma1: number;
          gamma2: number;
          volumeBeta: number;
          volumeGamma: number;
          baseFee: number;
        };
      }
    >;
  };

  estimateGas: {
    calculateVolumePerLiquidity(
      liquidity: BigNumberish,
      amount0: BigNumberish,
      amount1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    changeFeeConfiguration(
      feeConfig: {
        alpha1: BigNumberish;
        alpha2: BigNumberish;
        beta1: BigNumberish;
        beta2: BigNumberish;
        gamma1: BigNumberish;
        gamma2: BigNumberish;
        volumeBeta: BigNumberish;
        volumeGamma: BigNumberish;
        baseFee: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    getAverages(
      time: BigNumberish,
      tick: BigNumberish,
      index: BigNumberish,
      liquidity: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getFee(
      time: BigNumberish,
      tick: BigNumberish,
      index: BigNumberish,
      liquidity: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getSingleTimepoint(
      time: BigNumberish,
      secondsAgo: BigNumberish,
      tick: BigNumberish,
      index: BigNumberish,
      liquidity: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTimepoints(
      time: BigNumberish,
      secondsAgos: BigNumberish[],
      tick: BigNumberish,
      index: BigNumberish,
      liquidity: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initialize(
      time: BigNumberish,
      tick: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    timepoints(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    window(overrides?: CallOverrides): Promise<BigNumber>;

    write(
      index: BigNumberish,
      blockTimestamp: BigNumberish,
      tick: BigNumberish,
      liquidity: BigNumberish,
      volumePerLiquidity: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    calculateVolumePerLiquidity(
      liquidity: BigNumberish,
      amount0: BigNumberish,
      amount1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    changeFeeConfiguration(
      feeConfig: {
        alpha1: BigNumberish;
        alpha2: BigNumberish;
        beta1: BigNumberish;
        beta2: BigNumberish;
        gamma1: BigNumberish;
        gamma2: BigNumberish;
        volumeBeta: BigNumberish;
        volumeGamma: BigNumberish;
        baseFee: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    getAverages(
      time: BigNumberish,
      tick: BigNumberish,
      index: BigNumberish,
      liquidity: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getFee(
      time: BigNumberish,
      tick: BigNumberish,
      index: BigNumberish,
      liquidity: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getSingleTimepoint(
      time: BigNumberish,
      secondsAgo: BigNumberish,
      tick: BigNumberish,
      index: BigNumberish,
      liquidity: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTimepoints(
      time: BigNumberish,
      secondsAgos: BigNumberish[],
      tick: BigNumberish,
      index: BigNumberish,
      liquidity: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initialize(
      time: BigNumberish,
      tick: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    timepoints(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    window(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    write(
      index: BigNumberish,
      blockTimestamp: BigNumberish,
      tick: BigNumberish,
      liquidity: BigNumberish,
      volumePerLiquidity: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
